{"version":3,"sources":["constants.js","scripts/faceApiServer.js","scripts/benchmark.js","components/RegisterFace.js","components/AnalyzeImage.js","components/AutoTest.js","components/WebCam.js","components/NavBar.js","components/Results.js","scripts/faceApiWrapper.js","App.js","index.js","scripts/utils.js"],"names":["WEBCAM_ON_BUTTON_TEXT","WEBCAM_OFF_BUTTON_TEXT","PROCESS_IMAGE_BUTTON_TEXT","PROCESSING_IMAGE_BUTTON_TEXT","REGISTER_BUTTON_TEXT","REGISTERING_BUTTON_TEXT","AUTOTEST_TOOL_KEY","WEBCAM_TOOL_KEY","REGISTER_FACE_TOOL_KEY","ANALYZE_IMAGE_TOOL_KEY","FACE_API_ERROR_TEXT","WASM_BACKEND","CPU_BACKEND","WEBGL_BACKEND","SERVER_BACKEND","MAX_DESCRIPTOR_DISTANCE","FACE_DETECTOR_INPUT_SIZE","MODEL_PATH","WASM_PATH","BASE_URL","FACEAPI_ERROR_TEXT","FACE_DESCRIPTORS_KEY","SERVER_URL","RESULT_CONTAINER_ID","VIDEO_ID","IMAGE_ID","CANVAS_ID","BUTTON_SUCCESS_VARIANT","BUTTON_DANGER_VARIANT","IMAGE_PATH","START_TEST","STOP_TEST","IMAGE_SERVER_FORMAT","DATASET_SIZE","waitingForFrame","socket","socketIOClient","constants","on","loadedDescriptors","utils","emit","JSON","stringify","recognize","base64image","updateTimeStats","initialTime","Math","round","performance","now","response","a","success","canvas","document","createElement","base64canvas","image","getContext","drawImage","firstFrame","frameCount","RegisterFace","handleSubjectLabelUpdate","event","setState","subjectLabel","target","value","handleSubjectImagesUpdate","imageUrls","files","forEach","imageFile","imageUrl","URL","createObjectURL","push","subjectImages","handleRegisterSubjectSubmit","preventDefault","showSpinner","buttonText","images","state","src","props","registerSubject","Form","id","onSubmit","this","Group","Control","type","placeholder","onChange","File","label","custom","multiple","Button","Spinner","animation","size","hidden","React","Component","AnalyzeImage","handleProcessImageSubmit","processImageButtonText","recognizeFaces","media","isImage","handleImageUpdate","changeWebcamState","newWebcamState","showWebcam","webcamButtonText","webcamButtonVariant","disabled","downloadNewImage","running","imageCount","getNextImageURL","base64Image","generateLandmarks","startStopTest","updateImageCount","buttonVariant","buttonLabel","currentTimeCount","timeCount","progress","process","bind","length","className","variant","onClick","ProgressBar","totalTime","updateTimeRecords","newTime","getAverageTime","getFpsFromAverageTime","averageTime","WebCam","componentDidMount","startWebcam","constraints","video","navigator","mediaDevices","getUserMedia","stream","getElementById","onloadeddata","onPlay","srcObject","componentWillUnmount","callback","paused","ended","setTimeout","width","videoWidth","height","videoHeight","toDataURL","render","backendUrl","backend","window","location","origin","NavbarComponent","Navbar","bg","Brand","DropdownButton","title","Dropdown","Item","changeCurrentTool","tfBackend","Collapse","ButtonGroup","href","Results","alt","autoPlay","playsInline","muted","faceDetectorOptions","inputSize","labeledFaceDescriptors","setWasmPaths","faceapi","setBackend","ready","loadLabeledDescriptorsFromLocalStorage","Promise","all","catch","error","console","dimensions","getAllDetectionsForImage","detections","resizedDetections","drawLabeledDetectionsInCanvas","drawDetectionsInCanvas","ts","Date","result","time","log","getLabeledDescriptors","descriptorsForSubject","i","getDetectionForImage","detection","descriptor","newDescriptors","withFaceLandmarks","withFaceDescriptors","withFaceDescriptor","map","subject","descriptors","Float32Array","from","newSubject","detectSubjectsInImage","faceMatcher","findBestMatch","drawDetections","drawFaceLandmarks","box","text","toString","DrawBox","draw","faceApiServer","BACKEND","App","loadFaceApi","faceApi","then","tf","tensorflowReady","getBackend","faceApiReady","stats","fps","benchmark","successfulDetection","currentTool","getStatsText","getCurrentTool","AutoTest","require","ReactDOM","StrictMode","URLSearchParams","search","get","getSelectedBackend","getItemFromLocalStorage","key","parse","localStorage","getItem","saveLabeledDescriptorsInLocalStorage","setItem","showAutoTestResultsInContainer","timeArray","replaceChildren","buildAutoResultTable","showResultsInContainer","resultContainter","resultCanvas","resultImage","replaceChild","getBase64ImageFromUrl","crossOrigin","decode","clearResultsContainer","clearImageContents","clearVideoContents","clearCanvasContents","createImageFromBase64","Image","getCurrentAutoResultsFromLocalStorage","saveAutoResultsInLocalStorage","times","clearAutoTestResults","showAutoTestResults","calculateAutoTestStats","storeAutoTestResult","clearRect","resultVideo","shift","mean","stdev","results","table","setAttribute","Object","entries","row","title_cell","value_cell","appendChild","createTextNode"],"mappings":"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","file":"static/js/main.487d6ff9.chunk.js","sourcesContent":["export const WEBCAM_ON_BUTTON_TEXT = \"Turn webcam on\";\nexport const WEBCAM_OFF_BUTTON_TEXT = \"Turn webcam off\";\nexport const PROCESS_IMAGE_BUTTON_TEXT = \"Process\";\nexport const PROCESSING_IMAGE_BUTTON_TEXT = \"Processing\";\nexport const REGISTER_BUTTON_TEXT = \"Register\";\nexport const REGISTERING_BUTTON_TEXT = \"Registering\";\nexport const AUTOTEST_TOOL_KEY = \"webcam\";\nexport const WEBCAM_TOOL_KEY = \"webcam\";\nexport const REGISTER_FACE_TOOL_KEY = \"registerFace\";\nexport const ANALYZE_IMAGE_TOOL_KEY = \"analyzeImage\";\nexport const FACE_API_ERROR_TEXT = \"Error loading TensorFlow\";\n\n//Face-api\nexport const WASM_BACKEND = \"wasm\";\nexport const CPU_BACKEND = \"cpu\";\nexport const WEBGL_BACKEND = \"webgl\";\nexport const SERVER_BACKEND = \"server\";\nexport const MAX_DESCRIPTOR_DISTANCE = 0.6;\nexport const CANVAS_DISPLAY_WIDTH = 750;\nexport const FACE_DETECTOR_INPUT_SIZE = 96;\nexport const MODEL_PATH = './models/'\nexport const WASM_PATH = './wasm/'\nexport const BASE_URL = \"/Face-App?backend=\";\nexport const FACEAPI_ERROR_TEXT = \"Error loading Faceapi: \";\nexport const FACE_DESCRIPTORS_KEY = \"labeledFaceDescriptors\"\n\n//Server\nexport const SERVER_URL = \"https://face-app-server.herokuapp.com/\";\nexport const SERVER_URL_DEV = \"http://localhost:4000/\";\nexport const SEND_DESCRIPTORS_PATH = \"loadDescriptors\";\n\n//HTML\nexport const RESULT_CONTAINER_ID = \"resultContainer\";\nexport const VIDEO_ID = \"resultVideo\";\nexport const IMAGE_ID = \"resultImage\";\nexport const CANVAS_ID = \"resultCanvas\";\nexport const BUTTON_SUCCESS_VARIANT = \"success\";\nexport const BUTTON_DANGER_VARIANT = \"danger\";\n\n//AutoTest\nexport const IMAGE_PATH = \"/data/\";\nexport const START_TEST = \"START TEST\";\nexport const STOP_TEST = \"STOP TEST\";\nexport const IMAGE_SERVER_FORMAT = \".jpg\";\nexport const DATASET_SIZE = 13233;\n","import socketIOClient from \"socket.io-client\";\nimport * as constants from '../constants';\nimport * as utils from './utils';\n\nlet waitingForFrame = false;\n\nlet socket = socketIOClient(\n    process.env.NODE_ENV === \"production\" ?\n    constants.SERVER_URL : constants.SERVER_URL_DEV\n);\n\nsocket.on('connect', function() {\n    const loadedDescriptors = utils.getItemFromLocalStorage(constants.FACE_DESCRIPTORS_KEY);\n    socket.emit(\"sendDescriptors\", JSON.stringify(loadedDescriptors));\n})\n\nexport const recognize = (base64image, updateTimeStats) => {\n    if(waitingForFrame) return;\n    waitingForFrame = true;\n    const initialTime = Math.round(performance.now());\n    socket.emit(\"recognize\", {base64image, initialTime}, async (response) => {\n        waitingForFrame = false;\n        if(response.success) {\n            const canvas = document.createElement('canvas');\n            const image = await utils.createImageFromBase64(response.base64canvas);\n            canvas.getContext('2d').drawImage(image, 0, 0);\n            utils.showResultsInContainer({canvas, image});\n            updateTimeStats(Math.round(performance.now()) - response.initialTime);\n            return(true);\n        }\n        return(false);\n    })\n}","let firstFrame, frameCount, totalTime = 0;\n\nexport const getStatsFromTime = (newTime) => {\n    if(frameCount === 0) {\n        firstFrame = newTime;\n        frameCount ++;\n        return;\n    } \n    updateTimeRecords(newTime);\n    const averageTime = getAverageTime();\n    const fps = getFpsFromAverageTime(averageTime);\n    return {\n        newTime,\n        firstFrame,\n        averageTime,\n        fps\n    };\n}\n\nexport const clearStats = () => {\n    firstFrame = 0;\n    frameCount = 0;\n    totalTime = 0;\n} \n\nconst updateTimeRecords = (newTime) => {\n    totalTime += newTime;\n    frameCount++;\n}\n\nconst getAverageTime = () => Math.round(totalTime/(frameCount\n    ));\n\nconst getFpsFromAverageTime = (averageTime) => Math.round(1000 / averageTime);","import React from 'react';\nimport { Form, Button, Spinner } from 'react-bootstrap';\n\nimport * as constants from '../constants';\n\nclass RegisterFace extends React.Component {\n\n    constructor() {\n        super();\n        this.state = {\n            showSpinner: false,\n            buttonText: constants.REGISTER_BUTTON_TEXT,\n        };\n    }\n\n    handleSubjectLabelUpdate = (event) => {\n        this.setState({subjectLabel: event.target.value})\n    }\n\n    handleSubjectImagesUpdate = (event) => {\n        let imageUrls = [];\n        [...event.target.files].forEach(imageFile => {\n            const imageUrl = URL.createObjectURL(imageFile);\n            imageUrls.push(imageUrl);\n        });\n        this.setState({subjectImages: imageUrls})\n    }\n\n    handleRegisterSubjectSubmit = async (event) => {\n        event.preventDefault();\n        this.setState({showSpinner: true, buttonText:constants.REGISTERING_BUTTON_TEXT});\n        let images = [];\n        this.state.subjectImages.forEach(imageUrl => {\n            const image = document.createElement('img');\n            image.src = imageUrl;\n            images.push(image);\n        });\n        await this.props.registerSubject(this.state.subjectLabel, images);\n        this.setState({showSpinner: false, buttonText:constants.REGISTER_BUTTON_TEXT});\n    }\n\n    render() {\n        return (\n            <Form id=\"registerSubjectForm\" onSubmit={this.handleRegisterSubjectSubmit}>\n                <Form.Group>\n                    <Form.Control \n                        type=\"text\" \n                        placeholder=\"Name\" \n                        onChange={this.handleSubjectLabelUpdate}\n                    />\n                </Form.Group>\n                <Form.Group>\n                    <Form.File \n                        id=\"subjectImages\" \n                        label=\"Images of subject\" \n                        onChange={this.handleSubjectImagesUpdate}\n                        custom\n                        multiple\n                    />\n                </Form.Group>\n                <Form.Group>\n                    <Button id=\"subjectImagesSubmit\" type=\"submit\">\n                        {this.state.buttonText+\" \"}\n                        <Spinner\n                            animation=\"border\"\n                            size=\"sm\"\n                            hidden={!this.state.showSpinner}\n                        />\n                    </Button>\n                </Form.Group>\n            </Form>\n        )\n    }\n}\n\nexport default RegisterFace;","import React from 'react';\nimport { Form, Button, Spinner } from 'react-bootstrap';\n\nimport * as constants from '../constants';\n\nclass AnalyzeImage extends React.Component {\n\n    constructor() {\n        super();\n        this.state = {\n            showSpinner: false,\n            showWebcam: false,\n            processImageButtonText: constants.PROCESS_IMAGE_BUTTON_TEXT,\n            webcamButtonText: constants.WEBCAM_ON_BUTTON_TEXT,\n            webcamButtonVariant: constants.BUTTON_SUCCESS_VARIANT,\n        };\n    }\n\n    handleProcessImageSubmit = async (event) => {\n        event.preventDefault();\n        this.setState({\n            showSpinner:true, \n            processImageButtonText: constants.PROCESSING_IMAGE_BUTTON_TEXT\n        });\n        const image = document.createElement('img');\n        image.src = this.state.imageUrl;\n        await this.props.recognizeFaces({media: image, isImage: true});\n        this.setState({\n            showSpinner:false, \n            processImageButtonText:constants.PROCESS_IMAGE_BUTTON_TEXT\n        });\n    }\n\n    handleImageUpdate = async (event) => {\n        event.preventDefault();\n        this.setState({\n            imageUrl: URL.createObjectURL(event.target.files[0])\n        })\n    }\n\n    changeWebcamState = () => {\n        const newWebcamState = !this.state.showWebcam\n        this.props.changeWebcamState(newWebcamState);\n        this.setState({\n            showWebcam: newWebcamState,\n            webcamButtonText: newWebcamState ? constants.WEBCAM_OFF_BUTTON_TEXT : constants.WEBCAM_ON_BUTTON_TEXT,\n            webcamButtonVariant: newWebcamState ? constants.BUTTON_DANGER_VARIANT : constants.BUTTON_SUCCESS_VARIANT\n        })\n    }\n\n    render() {\n        return (\n            <Form id=\"analyzeImageForm\" onSubmit={this.handleProcessImageSubmit}>\n                <Form.Group>\n                    <Form.File \n                        type=\"file\" \n                        id=\"processImage\" \n                        label=\"Image to process\"\n                        onChange={this.handleImageUpdate}\n                        custom\n                    />\n                </Form.Group>\n                <Form.Group>\n                    <Button id=\"processImageSubmit\" type=\"submit\" disabled={this.state.showWebcam}>\n                        {this.state.processImageButtonText+\" \"}\n                        <Spinner\n                            animation=\"border\"\n                            size=\"sm\"\n                            hidden={!this.state.showSpinner}\n                        />\n                    </Button>\n                </Form.Group>\n            </Form>\n        )\n    }\n}\n\nexport default AnalyzeImage;","import React from 'react';\nimport { ProgressBar, Button } from 'react-bootstrap';\n\nimport * as constants from '../constants';\nimport * as utils from '../scripts/utils';\n\nconst IMAGE_PATH = constants.IMAGE_PATH;\nconst IMAGE_SERVER_FORMAT = constants.IMAGE_SERVER_FORMAT;\nconst DATASET_SIZE = constants.DATASET_SIZE;\nconst BUTTON_DANGER_VARIANT = constants.BUTTON_DANGER_VARIANT;\nconst BUTTON_SUCCESS_VARIANT = constants.BUTTON_SUCCESS_VARIANT;\nconst START_TEST = constants.START_TEST;\nconst STOP_TEST = constants.STOP_TEST;\n\nclass AnalyzeImage extends React.Component {\n\n    constructor() {\n        super();\n        this.state = {\n            progress: 0,\n            running: false,\n            buttonVariant: BUTTON_SUCCESS_VARIANT,\n            buttonLabel: START_TEST\n        };\n        this.startStopTest = this.startStopTest.bind(this);\n    }\n\n    componentDidMount() {\n        this.updateImageCount();\n        utils.showAutoTestResults();\n    }\n\n    updateImageCount() {\n        this.setState({ timeCount: utils.getCurrentAutoResultsFromLocalStorage().length });\n    }\n\n    downloadNewImage = async () => {\n        if (!this.state.running) return;\n        if (this.state.imageCount >= DATASET_SIZE) return;\n\n        const imageUrl = await this.getNextImageURL();\n        const base64Image = await utils.getBase64ImageFromUrl(imageUrl)\n\n        await this.props.generateLandmarks(base64Image);\n        await this.downloadNewImage();\n    }\n\n    startStopTest = async () => {\n        this.updateImageCount();\n        let buttonVariant = BUTTON_DANGER_VARIANT;\n        let buttonLabel = STOP_TEST;\n        let running = true;\n        if (this.state.running) {\n            buttonVariant = BUTTON_SUCCESS_VARIANT;\n            buttonLabel = START_TEST;\n            running = false;\n        }\n        this.setState({ buttonLabel, buttonVariant, running },\n            () => this.downloadNewImage())\n    }\n\n    getNextImageURL = () => {\n        utils.showAutoTestResults();\n        let currentTimeCount = this.state.timeCount + 1;\n        this.setState({\n            timeCount: currentTimeCount,\n            progress: Math.round((currentTimeCount / DATASET_SIZE) * 100)\n        });\n        let imageUrl = process.env.PUBLIC_URL +\n            IMAGE_PATH +\n            currentTimeCount +\n            IMAGE_SERVER_FORMAT;\n        return imageUrl;\n    }\n\n    render() {\n        return (\n            <div className=\"center\">\n                <div className=\"autotest-buttons\">\n                    <Button\n                        variant={this.state.buttonVariant}\n                        onClick={this.startStopTest}\n                    >\n                        {this.state.buttonLabel}\n                    </Button>{' '}\n                    <Button\n                        variant=\"info\"\n                        onClick={utils.clearAutoTestResults}\n                        disabled={this.state.running}\n                    >\n                        CLEAR RESULTS\n                    </Button>{' '}\n                </div>\n                <ProgressBar className=\"progressBar\"\n                    now={this.state.progress}\n                    label={`${this.state.progress}%`}\n                />\n            </div>\n        )\n    }\n}\n\nexport default AnalyzeImage;","import React from 'react';\n\nimport * as utils from '../scripts/utils.js';\nimport * as benchmark from '../scripts/benchmark.js';\nimport * as constants from '../constants.js';\n\nclass WebCam extends React.Component {\n\n    constructor() {\n        super();\n        this.state = {\n            video: false\n        };\n    }\n\n    componentDidMount = () => {\n        this.startWebcam();\n    }\n\n    startWebcam = async () => {\n        const constraints = { \n            video: {\n                \"height\": { \"exact\":300 },\n                \"width\": { \"exact\":300 },\n                \"mediaSource\": \"camera\"\n            }\n        };\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const video = document.getElementById(constants.VIDEO_ID);\n        if(!video) return;\n        video.onloadeddata = this.onPlay;\n        video.srcObject = stream;\n        benchmark.clearStats();\n        this.setState({video})\n    }\n\n    componentWillUnmount = () => {\n        utils.clearResultsContainer();\n        this.setState = (state,callback)=>{\n            return;\n        };\n    }\n\n    onPlay = async () => {\n        if (this.state.video.paused || this.state.video.ended) {\n            return setTimeout(() => this.onPlay())\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = this.state.video.videoWidth;\n        canvas.height = this.state.video.videoHeight;\n        canvas.getContext('2d').drawImage(this.state.video, 0, 0);\n        const base64Image = canvas.toDataURL('image/png');\n        await this.props.recognizeFaces(base64Image);\n        setTimeout(() => this.onPlay(), 100)\n    }\n\n    render = () => null; \n}\n\nexport default WebCam;\n","import React from 'react';\nimport { Navbar, ButtonGroup, Button, DropdownButton, Dropdown } from 'react-bootstrap';\n\nimport * as constants from '../constants';\n\nfunction NavbarComponent(props) {\n    return (\n        <Navbar bg=\"dark\" variant=\"dark\">\n            <Navbar.Brand>Face App</Navbar.Brand>\n            <DropdownButton title=\"Tools\" disabled>\n                <Dropdown.Item onClick={() => props.changeCurrentTool(constants.AUTOTEST_TOOL_KEY)}>\n                    AutoTest\n                </Dropdown.Item>\n                <Dropdown.Item onClick={() => props.changeCurrentTool(constants.WEBCAM_TOOL_KEY)}>\n                    Webcam\n                </Dropdown.Item>\n                <Dropdown.Item onClick={() => props.changeCurrentTool(constants.REGISTER_FACE_TOOL_KEY)}\n                    disabled={props.tfBackend === constants.SERVER_BACKEND}\n                >\n                    Register face\n                </Dropdown.Item>\n                <Dropdown.Item onClick={() => props.changeCurrentTool(constants.ANALYZE_IMAGE_TOOL_KEY)} disabled=\"true\">\n                    Analyze image\n                </Dropdown.Item>\n            </DropdownButton>\n            <Navbar.Collapse className=\"justify-content-end\">\n                <ButtonGroup size=\"sm\" className=\"mb-2\">\n                    <Button\n                        href={backendUrl(constants.WEBGL_BACKEND)}\n                        disabled={props.tfBackend === constants.WEBGL_BACKEND}\n                    >webgl</Button>\n                    <Button\n                        href={backendUrl(constants.CPU_BACKEND)}\n                        disabled={props.tfBackend === constants.CPU_BACKEND}\n                    >cpu</Button>\n                    <Button\n                        href={backendUrl(constants.WASM_BACKEND)}\n                        disabled={props.tfBackend === constants.WASM_BACKEND}\n                    >wasm</Button>\n                    <Button\n                        href={backendUrl(constants.SERVER_BACKEND)}\n                        disabled={props.tfBackend === constants.SERVER_BACKEND}\n                    >server</Button>\n                </ButtonGroup>\n            </Navbar.Collapse>\n        </Navbar>)\n}\n\nconst backendUrl = (backend) => window.location.origin + constants.BASE_URL + backend;\n\nexport default NavbarComponent;","import React from 'react';\n\nimport * as constants from '../constants';\n\nfunction Results(props) {\n    return (\n        <div id={constants.RESULT_CONTAINER_ID}>\n            <img id={constants.IMAGE_ID} alt=\"\"></img>\n            <video id={constants.VIDEO_ID} autoPlay playsInline muted></video>\n            <canvas id={constants.CANVAS_ID}></canvas>\n        </div>\n    )\n}\n\nexport default Results;","import { setWasmPaths } from '@tensorflow/tfjs-backend-wasm';\n\nimport * as faceapi from '@vladmandic/face-api/dist/face-api.esm.js';\nimport * as utils from './utils';\nimport * as constants from '../constants';\n\nconst faceDetectorOptions = { inputSize: constants.FACE_DETECTOR_INPUT_SIZE };\nconst useTinyModel = true;\nlet labeledFaceDescriptors = [];\n\nexport async function loadTensorFlow(backend = constants.WEBGL_BACKEND) {\n    await setWasmPaths(constants.WASM_PATH);\n    await faceapi.tf.setBackend(backend);\n    await faceapi.tf.ready();\n    return faceapi.tf;\n}\n\nexport async function loadFaceApi() {\n    await loadLabeledDescriptorsFromLocalStorage();\n    return Promise.all([\n        faceapi.loadTinyFaceDetectorModel(constants.MODEL_PATH),\n        faceapi.loadFaceLandmarkTinyModel(constants.MODEL_PATH),\n        faceapi.loadFaceRecognitionModel(constants.MODEL_PATH),\n    ])\n        .catch((error) => console.error(constants.FACEAPI_ERROR_TEXT, error));\n}\n\nexport async function recognize(image) {\n    image = await utils.createImageFromBase64(image);\n    await faceapi.awaitMediaLoaded(image);\n    const canvas = await faceapi.createCanvasFromMedia(image);\n    const dimensions = await faceapi.matchDimensions(canvas, image);\n    const detections = await getAllDetectionsForImage(image);\n    if (detections.length === 0) return false;\n    const resizedDetections = await faceapi.resizeResults(detections, dimensions);\n    if (labeledFaceDescriptors.length > 0) {\n        await drawLabeledDetectionsInCanvas(resizedDetections, canvas);\n    } else {\n        await drawDetectionsInCanvas(resizedDetections, canvas);\n    }\n    utils.showResultsInContainer({ canvas });\n    return true;\n}\n\nexport async function generateLandmarks(image) {\n    try {\n        image = await utils.createImageFromBase64(image);\n        await faceapi.awaitMediaLoaded(image);\n        const ts = Date.now();\n        const detections = await getAllDetectionsForImage(image);\n        if (detections.length === 0) return { result: false, time: Date.now() - ts };\n        return { result: true, time: Date.now() - ts };\n    } catch (error) {\n        console.log(\"Could not process image:\" + error);\n        return ({ result: false });\n    }\n}\n\nexport async function getLabeledDescriptors(label, images) {\n    let descriptorsForSubject = [];\n    for (let i = 0; i < images.length; i++) {\n        await faceapi.awaitMediaLoaded(images[i]);\n        const detection = await getDetectionForImage(images[i]);\n        descriptorsForSubject.push(detection.descriptor);\n    }\n    const newDescriptors = await new faceapi.LabeledFaceDescriptors(label, descriptorsForSubject);\n    labeledFaceDescriptors.push(newDescriptors);\n    utils.saveLabeledDescriptorsInLocalStorage(labeledFaceDescriptors);\n}\n\nexport async function getAllDetectionsForImage(image) {\n    return await faceapi\n        .detectAllFaces(image, new faceapi.TinyFaceDetectorOptions(faceDetectorOptions))\n        .withFaceLandmarks(useTinyModel)\n        .withFaceDescriptors();\n}\n\nasync function getDetectionForImage(image) {\n    return await faceapi\n        .detectSingleFace(image, new faceapi.TinyFaceDetectorOptions(faceDetectorOptions))\n        .withFaceLandmarks(useTinyModel)\n        .withFaceDescriptor();\n}\n\nasync function loadLabeledDescriptorsFromLocalStorage() {\n    const loadedDescriptors = await utils.getItemFromLocalStorage(constants.FACE_DESCRIPTORS_KEY);\n    if (!loadedDescriptors) return;\n    loadedDescriptors.map(async (subject) => {\n        const newSubject = new faceapi.LabeledFaceDescriptors(\n            subject.label,\n            await subject.descriptors.map((descriptor) => Float32Array.from(descriptor))\n        );\n        labeledFaceDescriptors.push(newSubject);\n    });\n}\n\nasync function detectSubjectsInImage(detections) {\n    const faceMatcher = new faceapi.FaceMatcher(labeledFaceDescriptors, constants.MAX_DESCRIPTOR_DISTANCE);\n    return detections.map(detection =>\n        faceMatcher.findBestMatch(detection.descriptor)\n    );\n}\n\nfunction drawDetectionsInCanvas(detections, canvas) {\n    faceapi.draw.drawDetections(canvas, detections);\n    faceapi.draw.drawFaceLandmarks(canvas, detections);\n}\n\nasync function drawLabeledDetectionsInCanvas(detections, canvas) {\n    const labeledDetections = await detectSubjectsInImage(detections);\n    labeledDetections.forEach((detection, i) => {\n        const box = detections[i].detection.box;\n        const text = detection.toString();\n        const drawBox = new faceapi.draw.DrawBox(box, { label: text });\n        drawBox.draw(canvas);\n    })\n}\n","import React from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport RegisterFace from './components/RegisterFace';\nimport AnalyzeImage from './components/AnalyzeImage';\nimport AutoTest from './components/AutoTest';\nimport WebCam from './components/WebCam';\n\nimport Navbar from './components/NavBar';\nimport Results from './components/Results';\n\nimport * as benchmark from './scripts/benchmark.js';\nimport * as faceApi from './scripts/faceApiWrapper.js';\nimport * as utils from './scripts/utils.js';\nimport * as constants from './constants.js';\n\nconst BACKEND = utils.getSelectedBackend();\n\nlet faceApiServer;\n\nclass App extends React.Component {\n\n    constructor() {\n        super();\n        this.state = {\n            tensorflowReady: false,\n            faceApiReady: false,\n            currentTool: constants.WEBCAM_TOOL_KEY\n        };\n    }\n\n    componentDidMount() {\n        if (BACKEND === constants.SERVER_BACKEND) {\n            faceApiServer = require('./scripts/faceApiServer.js');\n        } else {\n            this.loadFaceApi();\n        }\n    }\n\n    loadFaceApi = () => {\n        faceApi.loadTensorFlow(BACKEND)\n            .then((tf) => this.setState({ tensorflowReady: true, tfBackend: tf.getBackend() }))\n            .then(() => faceApi.loadFaceApi())\n            .then(() => this.setState({ faceApiReady: true }))\n            .catch((error) => console.error(constants.FACE_API_ERROR_TEXT, error));\n    }\n\n    updateTimeStats = (newTime) => {\n        const stats = benchmark.getStatsFromTime(newTime);\n        this.setState({ stats });\n    }\n\n    registerSubject = async (label, images) => {\n        await faceApi.getLabeledDescriptors(label, images);\n    }\n\n    recognizeFaces = async (base64image) => {\n        const ts = Date.now();\n        let successfulDetection = false;\n        if (BACKEND === constants.SERVER_BACKEND) {\n            successfulDetection = await faceApiServer.recognize(base64image, this.updateTimeStats);\n        } else {\n            successfulDetection = await faceApi.recognize(base64image);\n        }\n        if (successfulDetection) {\n            this.updateTimeStats(Date.now() - ts);\n        }\n    }\n\n    generateLandmarks = async (base64image) => {\n        const { result, time } = await faceApi.generateLandmarks(base64image);\n        if (result) utils.storeAutoTestResult(time);\n    }\n\n    changeCurrentTool = (currentTool) => {\n        utils.clearResultsContainer();\n        this.setState({ currentTool, stats: null });\n    }\n\n    getStatsText = () => {\n        if (!this.state.stats) return;\n        return `First Frame: ${this.state.stats.firstFrame} ms` +\n            ` | Average Time: ${this.state.stats.averageTime} ms` +\n            ` | New Time: ${this.state.stats.newTime} ms` +\n            ` | ${this.state.stats.fps} fps`\n    }\n\n    getCurrentTool = () => {\n        switch (this.state.currentTool) {\n            case constants.AUTOTEST_TOOL_KEY:\n                return (\n                    <AutoTest\n                        generateLandmarks={this.generateLandmarks}\n                        changeWebcamState={this.changeWebcamState}\n                    />\n                )\n            case constants.WEBCAM_TOOL_KEY:\n                return (\n                    <WebCam\n                        recognizeFaces={this.recognizeFaces}\n                    />\n                )\n            case constants.REGISTER_FACE_TOOL_KEY:\n                return (\n                    <RegisterFace\n                        registerSubject={this.registerSubject}\n                    />\n                )\n            case constants.ANALYZE_IMAGE_TOOL_KEY:\n                return (\n                    <AnalyzeImage\n                        recognizeFaces={this.recognizeFaces}\n                        changeWebcamState={this.changeWebcamState}\n                    />\n                )\n            default:\n                break;\n        }\n    }\n\n    render() {\n        if (!this.state.tensorflowReady && BACKEND !== constants.SERVER_BACKEND) {\n            return (<p>Loading TensorFlow...</p>)\n        }\n        if (!this.state.faceApiReady && BACKEND !== constants.SERVER_BACKEND) {\n            return (<p>Loading FaceApi...</p>)\n        }\n        else {\n            return (\n                <div className=\"App\">\n                    <Navbar\n                        changeCurrentTool={this.changeCurrentTool}\n                        tfBackend={this.state.tfBackend || BACKEND}\n                    />\n                    <div className=\"center\">\n                        {this.getCurrentTool()}\n                    </div>\n                    <Results />\n                    <p className=\"stats\">\n                        {this.getStatsText()}\n                    </p>\n                </div>\n            );\n        }\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","import * as constants from '../constants';\nimport stats from 'stats-lite';\n\nconst BACKEND = new URLSearchParams(window.location.search).get('backend') || 'webgl';\n\nexport const getSelectedBackend = () => {\n    return BACKEND;\n}\n\nexport const getItemFromLocalStorage = (key) => {\n    return JSON.parse(localStorage.getItem(key));\n}\n\nexport const setItemInLocalStorage = (key, value) => {\n    localStorage.setItem(key, JSON.stringify(value));\n}\n\nexport async function saveLabeledDescriptorsInLocalStorage(labeledFaceDescriptors) {\n    return localStorage.setItem(constants.FACE_DESCRIPTORS_KEY, JSON.stringify(labeledFaceDescriptors))\n}\n\nexport const showAutoTestResultsInContainer = async (timeArray) => {\n    const resultContainter = document.getElementById(constants.RESULT_CONTAINER_ID);\n    resultContainter.replaceChildren(buildAutoResultTable(timeArray))\n}\n\nexport const showResultsInContainer = async ({ image, canvas }) => {\n    const resultContainter = document.getElementById(constants.RESULT_CONTAINER_ID);\n    const resultCanvas = document.getElementById(constants.CANVAS_ID);\n    const resultImage = document.getElementById(constants.IMAGE_ID);\n    if (canvas) {\n        canvas.id = constants.CANVAS_ID;\n        resultContainter.replaceChild(canvas, resultCanvas);\n    }\n    if (image) {\n        image.id = resultImage.id;\n        resultContainter.replaceChild(image, resultImage);\n    }\n}\n\nexport const getBase64ImageFromUrl = async (imageUrl) => {\n    const image = document.createElement(\"img\");\n    image.src = imageUrl;\n    image.crossOrigin = \"anonymous\"\n    try {\n        await image.decode();\n    } catch (error) {\n        console.error(error);\n        return;\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    canvas.getContext('2d').drawImage(image, 0, 0);\n    return canvas.toDataURL('image/png');\n}\n\nexport const clearResultsContainer = () => {\n    clearImageContents();\n    clearVideoContents();\n    clearCanvasContents();\n}\n\nexport const createImageFromBase64 = async (base64Image) => {\n    try {\n        const image = new Image();\n        image.src = base64Image;\n        image.width = base64Image.width || 300;\n        image.height = base64Image.height || 300;\n        return image;\n    } catch (error) {\n        return;\n    }\n}\n\nexport const getCurrentAutoResultsFromLocalStorage = () => {\n    return getItemFromLocalStorage(BACKEND + \"_times\") || [];\n}\n\nexport const saveAutoResultsInLocalStorage = (times) => {\n    setItemInLocalStorage(`${BACKEND}_times`, times);\n}\n\nexport const clearAutoTestResults = async () => {\n    const emptyArray = [];\n    saveAutoResultsInLocalStorage(emptyArray);\n    showAutoTestResults();\n}\n\nexport const showAutoTestResults = () => {\n    let timeArray = getCurrentAutoResultsFromLocalStorage();\n    showAutoTestResultsInContainer(calculateAutoTestStats(timeArray), BACKEND)\n}\n\nexport const storeAutoTestResult = (time) => {\n    let timeArray = getCurrentAutoResultsFromLocalStorage();\n    if (!timeArray) timeArray = [];\n    timeArray.push(time);\n    saveAutoResultsInLocalStorage(timeArray);\n}\n\nconst clearImageContents = () => {\n    const resultImage = document.getElementById(constants.IMAGE_ID);\n    if (resultImage) resultImage.src = \"//:0\";\n}\n\nconst clearCanvasContents = () => {\n    const resultCanvas = document.getElementById(constants.CANVAS_ID);\n    if (resultCanvas) {\n        const canvasContext = resultCanvas.getContext('2d');\n        canvasContext.clearRect(0, 0, resultCanvas.width, resultCanvas.height);\n    }\n}\n\nconst clearVideoContents = () => {\n    const resultVideo = document.getElementById(constants.VIDEO_ID);\n    if (resultVideo) resultVideo.srcObject = null;\n}\n\nconst calculateAutoTestStats = (timeArray) => {\n    const result = {};\n    result[\"Backend\"] = BACKEND;\n    result[\"Total images\"] = timeArray.length;\n    result[\"First image\"] = `${timeArray[0]} ms`;\n    timeArray.shift(); // Do not use first time\n    result[\"Average\"] = `${Math.round(stats.mean(timeArray) * 100) / 100} ms`;\n    result[\"Stdev\"] = `${Math.round(stats.stdev(timeArray) * 100) / 100} ms`;\n    return result;\n}\n\nconst buildAutoResultTable = (results) => {\n    const table = document.createElement('table');\n    table.setAttribute(\"border\", \"2\");\n\n    Object.entries(results).forEach(([key, value]) => {\n        const row = document.createElement(\"tr\");\n        const title_cell = document.createElement(\"td\");\n        const value_cell = document.createElement(\"td\");\n\n        title_cell.appendChild(document.createTextNode(key));\n        value_cell.appendChild(document.createTextNode(value));\n\n        row.appendChild(title_cell);\n        row.appendChild(value_cell);\n        table.appendChild(row);\n    });\n\n    return table;\n}"],"sourceRoot":""}